
const int MAX_DIRECTIONAL_LIGHTS = 4;
const int MAX_POINT_LIGHTS = 4;
const int MAX_SPOT_LIGHTS = 4;

struct orb_BaseLight
{
	vec3 color;
	float intensity;
};

struct orb_DirectionalLight
{
	orb_BaseLight base;
	vec3 direction;
};

struct orb_Attenuation
{
	float constant;
	float linear;
	float exponential;
};

struct orb_PointLight
{
	orb_BaseLight base;
	vec3 position;

	orb_Attenuation attenuation;
	float radius;
};

struct orb_SpotLight
{
	orb_PointLight pointLight;
	vec3 direction;
	float cutoff;
};

struct orb_LightResult
{
	vec3 ambient;
	vec3 diffuse;
	vec3 specular;
};

orb_LightResult calcLight(orb_BaseLight base, vec3 direction, vec3 normal, vec3 viewPos, vec3 worldPos, float specularIntensity, float specularPower)
{
	orb_LightResult result;

	vec3 lightDirection = normalize(-direction);

	// Diffuse
	float diffuseFactor = max(dot(normal, lightDirection), 0.0);
	result.diffuse = base.color * base.intensity * diffuseFactor;

	//// Specular
	//vec3 viewDirection = normalize(viewPos - worldPos);
	//vec3 reflectDirection = reflect(-lightDirection, normal);
	//float specularFactor = pow(max(dot(viewDirection, reflectDirection), 0.0), specularPower);
	//result.specular = base.color * specularIntensity * specularFactor;

	// Blinn-Phong Specular
	vec3 viewDirection = normalize(viewPos - worldPos);
	vec3 halfwayDirection = normalize(lightDirection + viewDirection);
	float specularFactor = pow(max(dot(normal, halfwayDirection), 0.0), specularPower);
	result.specular = base.color * specularIntensity * specularFactor;

	return result;
}

orb_LightResult calcDirectionalLight(orb_DirectionalLight directionalLight, vec3 normal, vec3 viewPos, vec3 worldPos, float specularIntensity, float specularPower)
{
	return calcLight(directionalLight.base, directionalLight.direction, normal, viewPos, worldPos, specularIntensity, specularPower);
}

orb_LightResult calcPointLight(orb_PointLight pointLight, vec3 normal, vec3 viewPos, vec3 worldPos, float specularIntensity, float specularPower)
{
	orb_LightResult result;

	vec3 lightDirection = normalize(worldPos - pointLight.position);
	float distanceToPointLight = length(worldPos - pointLight.position);

	if (distanceToPointLight <= pointLight.radius)
	{
		float attenuation = 1.0 / (0.00001 +	// Prevent division by 0
			pointLight.attenuation.constant +
			pointLight.attenuation.linear * distanceToPointLight +
			pointLight.attenuation.exponential * distanceToPointLight * distanceToPointLight);

		result = calcLight(pointLight.base, lightDirection, normal, viewPos, worldPos, specularIntensity, specularPower);
		result.diffuse *= attenuation;
		result.specular *= attenuation;
	}

	return result;
}

orb_LightResult calcSpotLight(orb_SpotLight spotLight, vec3 normal, vec3 viewPos, vec3 worldPos, float specularIntensity, float specularPower)
{
	orb_LightResult result;

	vec3 lightDirection = normalize(worldPos - spotLight.pointLight.position);
	float spotFactor = dot(lightDirection, spotLight.direction);

	if (spotFactor > spotLight.cutoff)
	{
		result = calcPointLight(spotLight.pointLight, normal, viewPos, worldPos, specularIntensity, specularPower);

		result.diffuse *= (1.0 - (1.0 - spotFactor) / (1.0 - spotLight.cutoff));
		result.specular *= (1.0 - (1.0 - spotFactor) / (1.0 - spotLight.cutoff));
	}

	return result;
}


// General data and method for calculate all lights (forward rendering)
uniform vec3 orb_ViewPos;
uniform vec3 orb_AmbientLight;
uniform orb_DirectionalLight orb_DirectionalLights[MAX_DIRECTIONAL_LIGHTS];
uniform orb_PointLight orb_PointLights[MAX_POINT_LIGHTS];
uniform orb_SpotLight orb_SpotLights[MAX_SPOT_LIGHTS];

orb_LightResult calcLights(vec3 normal, vec3 worldPos)
{
	orb_LightResult result;
	result.ambient = orb_AmbientLight;

	for (int i = 0; i < MAX_DIRECTIONAL_LIGHTS; ++i)
	{
		if (orb_DirectionalLights[i].base.intensity > 0.0)
		{
			orb_LightResult directionalLight = calcDirectionalLight(orb_DirectionalLights[i], normal, orb_ViewPos, worldPos, 0, 0);
			result.diffuse += directionalLight.diffuse;
			result.specular += directionalLight.specular;
		}
	}

	for (int i = 0; i < MAX_POINT_LIGHTS; ++i)
	{
		if (orb_PointLights[i].base.intensity > 0.0)
		{
			orb_LightResult pointLight = calcPointLight(orb_PointLights[i], normal, orb_ViewPos, worldPos, 0, 0);
			result.diffuse += pointLight.diffuse;
			result.specular += pointLight.specular;
		}
	}

	for (int i = 0; i < MAX_SPOT_LIGHTS; ++i)
	{
		if (orb_SpotLights[i].pointLight.base.intensity > 0.0)
		{
			orb_LightResult spotLight = calcSpotLight(orb_SpotLights[i], normal, orb_ViewPos, worldPos, 0, 0);
			result.diffuse += spotLight.diffuse;
			result.specular += spotLight.specular;
		}
	}
	return result;
}
